import numpy as np
import matplotlib.pyplot as plt

# Planar Robot Kinematics Functions

# Homogeneous transformation matrix
def trans_mat_cc(kappa, l):
#Mapping from configuration parameters to task space
# tip frame is aligned so that the x-axis points toward the center of the
# circle
#
# INPUT:
# kappa: curvature
# l: trunk length
#
# OUTPUT:
# T: Transformation matrices containing orientation and position
    # num = sect_points: points per section
    si=np.linspace(0,l, num = 50);
    T= np.zeros((len(si),16));
    
    for i in range(len(si)):
        s=si[i];
        c_ks=np.cos(kappa*s);
        s_ks=np.sin(kappa*s);
        if kappa==0:
            T[i,:] = np.array([c_ks,s_ks,0,0,-s_ks,c_ks,0,0,0,0,1,0,0,s,0,1]);  
        else:
            T[i,:] = np.array([c_ks,s_ks,0,0,-s_ks,c_ks,0,0,0,0,1,0,(c_ks-1)/kappa,s_ks/kappa,0,1]);

    return T


# The forward kinematics for an n section manipulator can then be generated by the product of 
# n matrices. The forward kinematics for our elephant trunk robot 
# with its n sections can be calculated as
def coupletransformations(T,T_tip):
    
#Find orientation and position of distal section
#(Multiply T of current section with T at tip of previous section)
#INPUT:
#T: Transformation matrices of current section
#T_tip: Transformation at tip of previous section
#OUTPUT:
#Tc: coupled Transformation matrix

    Tc=np.zeros((len(T[:,0]),len(T[0,:])));
    for k in range(len(T[:,0])):
        #Tc[k,:].reshape(-1,1)
        p = np.matmul(T_tip,(np.reshape(T[k,:],(4,4),order='F')))
        Tc[k,:] = np.reshape(p,(16,),order='F');
    return Tc


# from configuration space (kappa, length) to task space (x,y)

# parameters
kappa1 = 1.7035; # 1/m
l1 = 0.1000; # metre
kappa2 = 1.0000; # 1/m
l2 = 0.1000; # metre
kappa3 = 2.0000; # 1/m
l3 = 0.1000; # metre

if kappa1 > 16 or kappa1 < -4:
    print("Please enter the First Curvature values between -4 and 16")
    kappa1 = 0;

elif kappa2 > 16 or kappa2 < -4:
    print("Please enter the Second Curvature values between -4 and 16")
    kappa2 = 0;

elif kappa3 > 16 or kappa3 < -4:
    print("Please enter the Third Curvature values between -4 and 16")
    kappa3 = 0;
    
else:
    print("Curvature Values for Each Segment are Appropriate")
    
    
# section 1
T1_cc = trans_mat_cc(kappa1,l1)
T1_tip = np.reshape(T1_cc[len(T1_cc)-1,:],(4,4),order='F');

# section 2
T2 = trans_mat_cc(kappa2, l2);
T2_cc = coupletransformations(T2,T1_tip);
T2_tip = np.reshape(T2_cc[len(T2_cc)-1,:],(4,4),order='F');

# section 3
T3 = trans_mat_cc(kappa3, l3);
T3_cc = coupletransformations(T3,T2_tip);

# Plot the trunk with three sections and point the section seperation
plt.scatter(T1_cc[0,12],T1_cc[0,13],linewidths=5,color = 'black',label="Section Seperation")
plt.plot(T1_cc[:,12],T1_cc[:,13],'b',linewidth=3,label="First Section")
plt.scatter(T1_cc[-1,12],T1_cc[-1,13],linewidths=5,color = 'black')
plt.plot(T2_cc[:,12],T2_cc[:,13],'r',linewidth=3,label="Second Section")
plt.scatter(T2_cc[-1,12],T2_cc[-1,13],linewidths=5,color = 'black')
plt.plot(T3_cc[:,12],T3_cc[:,13],'g',linewidth=3,label="Third Section")
plt.scatter(T3_cc[-1,12],T3_cc[-1,13],linewidths=5,color = 'black')
plt.legend(loc="best")
plt.title("2D Continuum Robot")
plt.xlabel("X - Position")
plt.ylabel("Y - Position")
plt.show()